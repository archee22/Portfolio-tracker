import streamlit as st
import psycopg2
import pandas as pd
import plotly.express as px

# 1. Database Connection and Schema
# Replace with your PostgreSQL credentials
DB_PARAMS = {
    "dbname": "PORTFOLIO TRACKER",
    "user":"postgres",
    "password":"1234",
    "host": "localhost",
    "port": "5432"
}

def get_db_connection():
    """Establishes a connection to the PostgreSQL database."""
    try:
        conn = psycopg2.connect(**DB_PARAMS)
        return conn
    except psycopg2.DatabaseError as e:
        st.error(f"Database connection error: {e}")
        return None

def create_tables():
    """Creates database tables if they do not exist."""
    conn = get_db_connection()
    if conn:
        with conn.cursor() as cursor:
            # Table for a single User
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    user_id SERIAL PRIMARY KEY,
                    username VARCHAR(50) UNIQUE NOT NULL
                );
            """)
            # Table for different accounts (e.g., brokerage, retirement)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS accounts (
                    account_id SERIAL PRIMARY KEY,
                    user_id INT NOT NULL REFERENCES users(user_id),
                    account_name VARCHAR(100) NOT NULL,
                    account_type VARCHAR(50) NOT NULL,
                    UNIQUE (user_id, account_name)
                );
            """)
            # Table for logging all transactions
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS transactions (
                    transaction_id SERIAL PRIMARY KEY,
                    account_id INT NOT NULL REFERENCES accounts(account_id),
                    ticker_symbol VARCHAR(10) NOT NULL,
                    transaction_type VARCHAR(20) NOT NULL CHECK (transaction_type IN ('BUY', 'SELL', 'DIVIDEND')),
                    transaction_date TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                    shares NUMERIC(15, 6) NOT NULL,
                    price_per_share NUMERIC(15, 6) NOT NULL,
                    total_amount NUMERIC(15, 2) NOT NULL
                );
            """)
            conn.commit()
            cursor.close()
        conn.close()

# Initialize tables when the app starts
create_tables()

# 2. Streamlit App Interface
st.set_page_config(page_title="Personal Financial Portfolio Tracker", layout="wide")
st.title("Personal Financial Portfolio Tracker üìà")
st.subheader("Manage your investments, analyze portfolio performance, and track assets.")

# Sidebar for CRUD operations
st.sidebar.header("CRUD Operations")
menu = st.sidebar.radio("Select an action:", ["Add Transaction", "View Portfolio", "Update Transaction", "Delete Transaction"])

# --- Add Transaction (Create) ---
if menu == "Add Transaction":
    st.header("Add New Transaction üìù")
    with st.form("add_transaction_form"):
        account_id = st.number_input("Account ID", min_value=1, step=1)
        ticker_symbol = st.text_input("Ticker Symbol (e.g., AAPL)")
        transaction_type = st.selectbox("Transaction Type", ["BUY", "SELL", "DIVIDEND"])
        shares = st.number_input("Shares", min_value=0.0, step=0.001)
        price_per_share = st.number_input("Price per Share", min_value=0.0, step=0.01)
        
        submitted = st.form_submit_button("Add Transaction")
        
        if submitted:
            total_amount = shares * price_per_share
            conn = get_db_connection()
            if conn:
                try:
                    with conn.cursor() as cursor:
                        cursor.execute(
                            """
                            INSERT INTO transactions (account_id, ticker_symbol, transaction_type, shares, price_per_share, total_amount)
                            VALUES (%s, %s, %s, %s, %s, %s);
                            """,
                            (account_id, ticker_symbol, transaction_type, shares, price_per_share, total_amount)
                        )
                    conn.commit()
                    st.success("Transaction added successfully!")
                except psycopg2.DatabaseError as e:
                    conn.rollback()
                    st.error(f"Error adding transaction: {e}")
                finally:
                    conn.close()

# --- View Portfolio (Read) ---
elif menu == "View Portfolio":
    st.header("Current Portfolio Summary üìä")
    conn = get_db_connection()
    if conn:
        try:
            # Query all transactions to build a portfolio view
            df_transactions = pd.read_sql_query("SELECT * FROM transactions;", conn)
            
            if not df_transactions.empty:
                # Calculate total holdings
                df_holdings = df_transactions.groupby(['ticker_symbol', 'account_id']).apply(
                    lambda x: x[x['transaction_type'] == 'BUY']['shares'].sum() - x[x['transaction_type'] == 'SELL']['shares'].sum()
                ).reset_index(name='shares_held')

                st.write("### All Transactions")
                st.dataframe(df_transactions)
                st.write("---")

                st.write("### Current Holdings")
                st.dataframe(df_holdings[df_holdings['shares_held'] > 0])
                
                # --- Plotting with Plotly ---
                st.write("---")
                st.subheader("Portfolio Breakdown")
                
                # Plot pie chart of shares held by ticker
                fig_pie = px.pie(df_holdings, values='shares_held', names='ticker_symbol', title='Shares Held by Asset')
                st.plotly_chart(fig_pie, use_container_width=True)

            else:
                st.info("No transactions found. Please add a transaction to view your portfolio.")

        except Exception as e:
            st.error(f"Error fetching data: {e}")
        finally:
            conn.close()

# --- Update Transaction (Update) ---
elif menu == "Update Transaction":
    st.header("Update Existing Transaction ‚úèÔ∏è")
    transaction_id = st.number_input("Enter Transaction ID to update:", min_value=1, step=1)
    
    st.info("The following inputs will override the existing values for the specified Transaction ID.")
    
    col1, col2, col3 = st.columns(3)
    with col1:
        new_shares = st.number_input("New Number of Shares", min_value=0.0, step=0.001)
    with col2:
        new_price = st.number_input("New Price per Share", min_value=0.0, step=0.01)
    with col3:
        update_button = st.button("Update")

    if update_button:
        conn = get_db_connection()
        if conn:
            try:
                new_total_amount = new_shares * new_price
                with conn.cursor() as cursor:
                    cursor.execute(
                        """
                        UPDATE transactions
                        SET shares = %s, price_per_share = %s, total_amount = %s
                        WHERE transaction_id = %s;
                        """,
                        (new_shares, new_price, new_total_amount, transaction_id)
                    )
                conn.commit()
                st.success(f"Transaction ID {transaction_id} updated successfully!")
            except psycopg2.DatabaseError as e:
                conn.rollback()
                st.error(f"Error updating transaction: {e}")
            finally:
                conn.close()

# --- Delete Transaction (Delete) ---
elif menu == "Delete Transaction":
    st.header("Delete a Transaction üóëÔ∏è")
    transaction_id = st.number_input("Enter Transaction ID to delete:", min_value=1, step=1)
    delete_button = st.button("Delete")

    if delete_button:
        conn = get_db_connection()
        if conn:
            try:
                with conn.cursor() as cursor:
                    cursor.execute("DELETE FROM transactions WHERE transaction_id = %s;", (transaction_id,))
                conn.commit()
                st.success(f"Transaction ID {transaction_id} deleted successfully!")
            except psycopg2.DatabaseError as e:
                conn.rollback()
                st.error(f"Error deleting transaction: {e}")
            finally:
                conn.close()
